추가된 부분
iso::binary 인 경우 file open할떄
파일을 로드할때 객체로 저장할수 있다.
대신 바이너리 해야 한다.

1. save()함수에서 target = nullptr 이 필요한지 확인 필요 - 맞다
2. 복사 생성자는 PersonInfo 에서만 필요한지 확인 필요 - 맞다
3. 복사 생성자를 추가하면 디폴트 생성자도 추가해야 하는지 확인 필요 - 맞다
4. PersonalInfo의 멤버 변수를 private 로하면 외부에서 직접 접근이 되지 않는다. - set, get  함수 신설이 필요해 보임 - 맞다
조건 : 멤버함수에서만 접근하면 구현안해도 되고, 클래스 외부에서 접근할때는
각각의 멤버 변수마다 get, set 함수를 구현해야한다.

아래는 PersonalInfo관련해서 생성자, 복사생성자 관련해서 임시로 구현한 부분이다.
class PersonalInfo {
private:
	string name;
	string phone;
	string address;
public:
	// default constructor
	PersonalInfo(); // 디폴트 생성자???
	PersonalInfo(string, string, string); //일반생성자???

	// copy constructor
	PersonalInfo(PersonalInfo &info);

	//void setName(string);
	//string getName();
	//void setPhone(string);
	//string getPhone();
	//void setAddress(string);
	//string getAddress();

	// overloading operators
	PersonalInfo& operator= (PersonalInfo& info);
	bool operator== (PersonalInfo& info); //name기준
	bool operator== (string& info); //name기준
	ostream& operator<< (ostream& os);
};

PersonalInfo::PersonalInfo() {
	name = "";
	phone = "";
	address = "";
} //디폴트 생성자???

PersonInfo::PersonInfo(PersonInfo& info) {
	this->name = info.name;
	this->phone = info.phone;
	this->address = info.address;
} //복사 생성자

PersonalInfo::PersonalInfo(string name, string phone, string address) {
//일반생성자 우리는 안쓴다
	this->name = name;
	this->phone = phone;
	this->address = address;
}

연산자오버로딩활용

대입연자오버로딩
append 
1번 케이스
	newNode->info = new PersonalInfo;
	newNode->info->name = info.name;
	newNode->info->phone = info.phone;
	newNode->info->address = info.address;	
	newNode = info;
	
2번 케이스 - 복사생성자
	newNode->info = new PersonalInfo(info);
	//복사생성자도 구현이 되어있어야 가능하다.

동등비교연산자 ==
int List::findName(string name) {
원본
if (this->pos->info->name == name) {
갱신
if ( this->pos->info == name ) {
단 갱신을 사용하려면
PersonInfo 내에 bool operator== (string& name); 를 구현해야함

출력연산자 사용
ostream& PersonalInfo::operator<< (ostream& os) {
	os << os.width(8) << left << name << "  " ;
	os << os.width(12) << left <<phone << "  ";
	os << os.width(50) << left << address;
	return os;
}

void AddressBook::printPersonInfo(PersonalInfo &info, int printNum) {
	if (printNum != FALSE) {
		cout.width(4);
		cout << left << printNum;
		cout << "  ";
	}	
	cout << info;
	cout << endl;
	
}
